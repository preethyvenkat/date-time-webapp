pipeline {
    agent any

    environment {
        AWS_REGION       = 'us-east-1'
        EKS_CLUSTER      = 'date-time-webapp-cluster'
        MANIFEST_REPO    = 'git@github.com:preethyvenkat/date-time-webapp.git'
        ARGO_APP_NAME    = 'date-time-webapp'
        ARGO_NAMESPACE   = 'argocd'
        SSH_DEPLOY_KEY   = 'argocd-ssh-key'      // Jenkins SSH key for ArgoCD secret
        SSH_GIT_KEY      = 'github-creds'      // Jenkins SSH key for git push/pull
        ECR_REPO         = '141409473062.dkr.ecr.us-east-1.amazonaws.com/date-time-webapp'
        IMAGE_TAG        = "v${BUILD_NUMBER}"
    }

    stages {
       /* stage('Setup kubeconfig for EKS') {
            steps {
                withCredentials([usernamePassword(credentialsId: 'aws-creds', usernameVariable: 'AWS_ACCESS_KEY_ID', passwordVariable: 'AWS_SECRET_ACCESS_KEY')]) {
                    sh '''
                        mkdir -p ~/.aws
                        echo "[default]" > ~/.aws/credentials
                        echo "aws_access_key_id=$AWS_ACCESS_KEY_ID" >> ~/.aws/credentials
                        echo "aws_secret_access_key=$AWS_SECRET_ACCESS_KEY" >> ~/.aws/credentials
                        echo "[default]" > ~/.aws/config
                        echo "region=$AWS_REGION" >> ~/.aws/config

                        aws eks update-kubeconfig --region $AWS_REGION --name $EKS_CLUSTER
                    '''
                }
            }
        }

        stage('Install Argo CD') {
            steps {
                sh '''
                    kubectl get namespace $ARGO_NAMESPACE || kubectl create namespace $ARGO_NAMESPACE
                    kubectl get pods -n $ARGO_NAMESPACE | grep argocd-server || \
                    kubectl apply -n $ARGO_NAMESPACE -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml

                    echo "⏳ Waiting for Argo CD server pod to be ready..."
                    kubectl rollout status deployment/argocd-server -n $ARGO_NAMESPACE --timeout=300s
                '''
            }
        } */

        stage('Configure Argo CD Git Access') {
            steps {
                withCredentials([string(credentialsId: 'argocd-ssh-key', variable: 'SSH_KEY_CONTENT')]) {
                    sh '''
                        echo "$SSH_KEY_CONTENT" > /tmp/argo_cd_key
                        chmod 600 /tmp/argo_cd_key
                        kubectl -n $ARGO_NAMESPACE delete secret argocd-ssh-key || true
                        kubectl -n $ARGO_NAMESPACE create secret generic argocd-ssh-key \
                        --from-file=ssh-privatekey=/tmp/argo_cd_key \
                        --type=kubernetes.io/ssh-auth
                    '''
                }
            }
        }

        stage('Expose Argo CD via LoadBalancer') {
            steps {
                sh '''
                    kubectl patch svc argocd-server -n $ARGO_NAMESPACE -p '{"spec": {"type": "LoadBalancer"}}'

                    echo "⏳ Waiting for LoadBalancer external IP..."
                    for i in {1..20}; do
                        ARGO_URL=$(kubectl get svc argocd-server -n $ARGO_NAMESPACE -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
                        if [ ! -z "$ARGO_URL" ]; then
                            echo "Argo CD is accessible at: http://$ARGO_URL"
                            break
                        fi
                        echo "Waiting for external IP..."
                        sleep 15
                    done
                '''
            }
        }

        stage('Create or Update Argo CD Application') {
            steps {
                sh '''
                    if ! command -v argocd &> /dev/null; then
                        curl -sSL -o /usr/local/bin/argocd https://github.com/argoproj/argo-cd/releases/latest/download/argocd-linux-amd64
                        chmod +x /usr/local/bin/argocd
                    fi

                    ARGCD_SERVER=$(kubectl get svc argocd-server -n $ARGO_NAMESPACE -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
                    ARGOCD_PASSWORD=$(kubectl -n $ARGO_NAMESPACE get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d)

                    argocd login $ARGCD_SERVER --insecure --username admin --password $ARGOCD_PASSWORD

                    if argocd app get $ARGO_APP_NAME > /dev/null 2>&1; then
                        argocd app set $ARGO_APP_NAME \
                            --repo $MANIFEST_REPO \
                            --path k8s \
                            --dest-server https://kubernetes.default.svc \
                            --dest-namespace default
                        argocd app sync $ARGO_APP_NAME
                    else
                        argocd app create $ARGO_APP_NAME \
                            --repo $MANIFEST_REPO \
                            --path k8s \
                            --dest-server https://kubernetes.default.svc \
                            --dest-namespace default \
                            --sync-policy automated
                    fi

                    argocd app wait $ARGO_APP_NAME --health --timeout 300
                '''
            }
        }

        stage('Update Manifests in Git Repo') {
            steps {
                sshagent(credentials: [SSH_GIT_KEY]) {
                    sh '''
                        rm -rf manifests
                        git clone $MANIFEST_REPO manifests
                        cd manifests
                        git pull --rebase origin main

                        sed -i'' "s|image: .*|image: $ECR_REPO:$IMAGE_TAG|" k8s/deployment.yaml

                        git config user.email "preevenkat@gmail.com"
                        git config user.name "Preethy Venkat"

                        if git diff --quiet; then
                            echo "No changes to commit"
                        else
                            git add k8s/deployment.yaml
                            git commit -m "Update image to $IMAGE_TAG"
                            git push origin main
                        fi
                    '''
                }
            }
        }
    }

    post {
        success {
            slackSend(color: '#36a64f', message: "*✅ SUCCESS*: Pipeline `${env.JOB_NAME}` #${env.BUILD_NUMBER} completed.")
        }
        failure {
            slackSend(color: '#FF0000', message: "*❌ FAILURE*: Pipeline `${env.JOB_NAME}` #${env.BUILD_NUMBER} failed.")
        }
        cleanup {
            deleteDir()
        }
    }
}